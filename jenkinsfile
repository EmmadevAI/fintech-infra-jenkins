pipeline {
  agent { label 'ci-cd-node' }

  parameters {
    choice(name: 'ENVIRONMENT', choices: ['dev', 'qa', 'uat', 'prod'], description: 'Deployment Environment')
    string(name: 'REGION', defaultValue: 'us-west-2', description: 'AWS Region')
    choice(name: 'ACTION', choices: ['plan', 'apply', 'destroy'], description: 'Terraform action')
  }

  environment {
    TF_ENV              = "${params.ENVIRONMENT}"
    AWS_REGION          = "${params.REGION}"
    TF_DIR              = "${params.ENVIRONMENT}"   // env folder (dev/qa/uat/prod)
    TF_INPUT            = 'false'
    TF_IN_AUTOMATION    = 'true'
    TF_PLUGIN_CACHE_DIR = "${env.WORKSPACE}/.terraform.d/plugin-cache"
  }

  options {
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    timeout(time: 60, unit: 'MINUTES')
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        script { echo "Branch: ${env.BRANCH_NAME ?: 'N/A'} | PR: ${env.CHANGE_ID ?: 'no'}" }
      }
    }

    stage('WhoAmI') {
      steps {
        sh '''
          set -e
          aws --version || true
          echo "Base identity (instance profile):"
          aws sts get-caller-identity || true
        '''
      }
    }

    stage('Tooling Setup') {
      steps {
        sh '''
          set -e
          mkdir -p .terraform.d/plugin-cache
          terraform version || true
        '''
      }
    }

    stage('Init & Validate') {
      steps {
        sh '''
          bash -lc "set -euo pipefail
          cd \\"$TF_DIR\\"
          export TF_PLUGIN_CACHE_DIR=\\"$TF_PLUGIN_CACHE_DIR\\"
          terraform fmt -check -recursive
          terraform init -upgrade -backend-config=\\"key=$TF_ENV/terraform.tfstate\\" -lock-timeout=5m
          terraform validate -no-color
          aws sts get-caller-identity"
        '''
      }
    }

    stage('Plan') {
      when { anyOf { expression { params.ACTION == 'plan' }; expression { params.ACTION == 'apply' } } }
      steps {
        lock(resource: "tfstate-${params.ENVIRONMENT}") {
          sh '''
            bash -lc "set -euo pipefail
            cd \\"$TF_DIR\\"
            export TF_PLUGIN_CACHE_DIR=\\"$TF_PLUGIN_CACHE_DIR\\"
            terraform plan -no-color -compact-warnings -lock-timeout=5m \
              -var-file=\\"$TF_ENV.tfvars\\" \
              -out plan.tfplan
            terraform show -no-color plan.tfplan > plan.txt"
          '''
        }
        archiveArtifacts artifacts: "${TF_DIR}/plan.tfplan, ${TF_DIR}/plan.txt", fingerprint: true
        stash name: 'tf-plan-bundle', includes: "${TF_DIR}/plan.tfplan, ${TF_DIR}/plan.txt"
      }
    }

    stage('Approval') {
      when { anyOf { expression { params.ACTION == 'apply' }; expression { params.ACTION == 'destroy' } } }
      steps {
        timeout(time: 30, unit: 'MINUTES') {
          input message: "Approve ${params.ACTION.toUpperCase()} for ${params.ENVIRONMENT} in ${params.REGION}?",
                ok: 'Approve'
        }
      }
    }

    stage('Apply (with auto-overwrite)') {
      when { expression { params.ACTION == 'apply' } }
      steps {
        lock(resource: "tfstate-${params.ENVIRONMENT}") {
          unstash 'tf-plan-bundle'
          script {
            try {
              sh '''
                bash -lc "set -euo pipefail
                cd \\"$TF_DIR\\"
                export TF_PLUGIN_CACHE_DIR=\\"$TF_PLUGIN_CACHE_DIR\\"
                terraform init -lock-timeout=5m -backend-config=\\"key=$TF_ENV/terraform.tfstate\\"
                terraform apply -auto-approve -lock-timeout=5m plan.tfplan"
              '''
            } catch (err) {
              echo "⚠️ Terraform apply failed — attempting cleanup of conflicting resources..."

              // Handle IAM & EIP conflicts automatically
              sh '''
              set +e
              echo "Cleaning up duplicate IAM resources..."
              for name in EKSClientEKSAccessPolicy GithubRunnerEKSAccessPolicy prod-GitHubECRPolicy; do
                arn=$(aws iam list-policies --query "Policies[?PolicyName=='$name'].Arn" --output text)
                if [ ! -z "$arn" ]; then
                  echo "Deleting existing policy: $name"
                  aws iam delete-policy --policy-arn $arn || true
                fi
              done

              echo "Cleaning up duplicate IAM instance profiles..."
              aws iam delete-instance-profile --instance-profile-name github-runner-ssm-profile || true

              echo "Checking for excess Elastic IPs..."
              current_eip_count=$(aws ec2 describe-addresses --query "length(Addresses)" --output text)
              if [ "$current_eip_count" -ge 5 ]; then
                echo "Warning: Elastic IP limit reached. Releasing oldest EIP..."
                old_eip=$(aws ec2 describe-addresses --query "Addresses[0].AllocationId" --output text)
                aws ec2 release-address --allocation-id $old_eip || true
              fi
              set -e
              '''

              echo "♻️ Re-running Terraform apply after cleanup..."
              sh '''
                bash -lc "set -euo pipefail
                cd \\"$TF_DIR\\"
                terraform apply -auto-approve -lock-timeout=5m plan.tfplan"
              '''
            }
          }
        }
      }
    }

    stage('Destroy') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        lock(resource: "tfstate-${params.ENVIRONMENT}") {
          sh '''
            bash -lc "set -euo pipefail
            cd \\"$TF_DIR\\"
            export TF_PLUGIN_CACHE_DIR=\\"$TF_PLUGIN_CACHE_DIR\\"
            terraform init -lock-timeout=5m -backend-config=\\"key=$TF_ENV/terraform.tfstate\\"
            terraform destroy -auto-approve -lock-timeout=5m -var-file=\\"$TF_ENV.tfvars\\""
          '''
        }
      }
    }
  }

  post {
    success { echo "✅ ${params.ACTION} for ${params.ENVIRONMENT} in ${params.REGION} succeeded." }
    failure { echo "❌ ${params.ACTION} for ${params.ENVIRONMENT} in ${params.REGION} failed." }
    always  { cleanWs(deleteDirs: true, notFailBuild: true) }
  }
}
